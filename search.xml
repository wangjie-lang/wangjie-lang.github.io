<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM 解释器和编译器</title>
      <link href="/2022/03/29/JVM-%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2022/03/29/JVM-%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Java是一门解释执行和编译执行并存的语言。</p><p>JVM解释器让Java程序快速启动，编译器让Java程序高效运行，这是Java长久生存的一大重要原因。</p><h1 id="编译器和解释器的关系">1 编译器和解释器的关系</h1><p>在一个Java程序执行时，首先通过javac把java文件编译为虚拟机可以识别的class文件。然后由JVM解释器解释class文件中的字节码，通过JVM把解释结果转变为机器码执行。这是我们通常所说的解释执行。</p><p>C++这类语言都是直接把代码编译为机器码执行交给计算机执行，这是我们通常所说的编译执行。</p><p>两者的最大区别就是是否存在一个中间处理器去参与由代码到机器码的流程。</p><p>解释执行有个缺点就是每次都要解释字节码然后才生成机器码让计算机执行，解释的过程会占用很多的时间。于是JVM中诞生了编译器，编译器可以通过热点代码探测技术，找到运行次数最多的代码，把这些代码及时编译为机器码，在下次调用这些代码时跳过解释的步骤，直接执行编译好的机器码，以达到加速运行时间的目的。</p><p>Java语言解释器与编译器并存的理念让Java程序得到了更加智能处理结果，是Java语言的特色，也是Java语言的优势。</p><h1 id="解释器与编译器的工作模式">2 解释器与编译器的工作模式</h1><p>JVM分为Server模式和Client模式，对应的编译器也有C1（Client Complier）和C2（Server Complier）两个编译器。C1编译器注重编译的速度，C2编译器注重编译的质量。</p><p>不论在Server模式还是Client模式，解释器只有一个。早期的JVM中解释器只能和C1或C2中的一个混合运作（当然也可以通过设置虚拟机参数，强制只有编译器运作或只有解释器运作）。</p><p>在JDK1.7中，分层编译的加入，让两个编译器和一个解释器可以共同参与工作。</p><h2 id="分层编译">2.1 分层编译</h2><p>第0层：编译器不工作，只有解释器解释执行程序，可触发第二层编译。</p><p>第1层：解释器和C1编译器共同工作。把热点字节码编译为机器码，并进行简单可靠的优化，如有必要会开启性能监测。可触发               第2层编译。</p><p>第2层（或第2层以上）：解释器和C2编译器共同工作。把热点字节码编译为机器码，开启性能监测，并通过监测结果进行激进优化。</p><p>在开启分层编译后，由于两个编译器的加入，许多代码会被多次编译。既通过C1得到了更高的编译速度，也通过C2得到了更高的编译质量，是JVM代码执行系统的一大进步。</p><h2 id="激进优化">2.2 激进优化</h2><p>激进优化是不可靠的，所以进行激进优化时需要一个“逃生门”，通常由解释器担任，职责是在激进优化失败后继续完成任务。例如编译器优化措施中有一项优化方法名为“方法内联”。这个优化措施的行为大体是把方法体代码内嵌到它的调用者方法中，减少方法调用的成本。</p><p>但是Java的多态特性让这个优化有时不太可靠，因为在不具体执行方法之前，JVM并不知道该把多个子类中哪个类对应的方法体代码内联到调用者方法中。这时编译器会根据系统性能监测的结果，找到调用最多的方法体内码进行内嵌。</p><p>如果内嵌之后突然调用了一次其他子类的多态虚方法，这个内联方法就没有办法使用了，这时就出现了激进优化失败。这时只能通过预先设定的逃生门解决问题，由解释器不进行优化按照原始步骤解释执行代码完成这次任务。</p><h1 id="编译对象的选择">3 编译对象的选择</h1><p>编译器介入代码执行后，通过把字节码编译为机器码提升执行速度。被编译成机器码的主要有两项</p><p>被多次调用的方法和被多次执行的循环体。</p><h2 id="被多次调用的方法">3.1 被多次调用的方法</h2><p>被多次调用的方法很好理解，一个方法被执行的多了，把他编译器机器码确实对提升代码整体运行速度很有帮助。</p><p>判断一个方法是否被多次调用主要通过采样探测法和计数器探测法来进行。</p><p>采样探测法：虚拟机周期性的对方法栈内的方法进行采样统计，如果多次发现同一个方法在栈顶，则说明这个方法频繁的被调用。这时就把它标记为一个多次调用方法等待编译器编译。</p><p>计数器探测法：给每个方法绑定一个计数器，每次方法被调用时计数器加一。然后给系统设定一个阈值，当一段时间内方法的调用次数超过阈值时把它标记为多次调用的方法，等待编译器编译。我们常用的HotSpot虚拟机就是采用这种方法探测热点代码。</p><h2 id="方法调用流程">3.2 方法调用流程</h2><p>当编译器加入后，每个方法可以执行的代码就不止一份了。有一份字节码格式的方法代码，还有可能有多个机器码格式经过优化的方法代码。所以一个方法调用时会进行版本选择。</p><h2 id="被多次执行执行的循环体">3.3 被多次执行执行的循环体</h2><p>记录方法调用次数是用计数器实现的，记录循环执行次数也是用一种叫回边计数器实现的（这个计数器翻译的很棒啊）。在字节码中控制代码向后跳转的指令被称作“回边”。也就是说回边存在与循环体的末尾，所以回边计数器也存在于循环体的末尾。当回边计数器的值和方法调用计数器的和超过回边计数器的阈值时，就把这段循环体代码标记为多次执行循环体等待编译，并且把回边计数器的值下调一些让这次循环能按原规则执行完毕。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 参数调优</title>
      <link href="/2022/03/25/jvm-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>/2022/03/25/jvm-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="选择合适的垃圾回收器">1 选择合适的垃圾回收器</h1><ul><li><p>CPU单核，那么毫无疑问Serial 垃圾收集器是你唯一的选择。</p></li><li><p>CPU多核，关注吞吐量 ，那么选择PS+PO组合。</p></li><li><p>CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。</p></li><li><p>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。</p></li></ul><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Serial垃圾收集器（新生代）</span></span><br><span class="line"> 开启：-XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"> 开启 -XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CMS垃圾收集器（老年代）</span></span><br><span class="line"> 开启 -XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置G1垃圾收集器</span></span><br><span class="line"> 开启 -XX:+UseG1GC</span><br></pre></td></tr></table></figure><h1 id="调整内存大小">2 调整内存大小</h1><p>现象：垃圾收集频率非常频繁。</p><p>原因：如果内存太小，就会导致频繁的需要进行垃圾收集才能释放出足够的空间来创建新的对象，所以增加堆内存大小的效果是非常显而易见的。</p><p>注意：如果垃圾收集次数非常频繁，但是每次能回收的对象非常少，那么这个时候并非内存太小，而可能是内存泄露导致对象无法回收，从而造成频繁GC。</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置堆初始值</span></span><br><span class="line"> 指令<span class="number">1</span>：-Xms2g</span><br><span class="line"> 指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置堆区最大值</span></span><br><span class="line"> 指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line"> 指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line"></span><br><span class="line"> <span class="comment">//新生代内存配置</span></span><br><span class="line"> 指令<span class="number">1</span>：-Xmn512m</span><br><span class="line"> 指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure><h1 id="设置符合预期的停顿时间">3 设置符合预期的停顿时间</h1><p>现象：程序间接性的卡顿</p><p>原因：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。</p><p>注意：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间</span></span><br><span class="line"> -XX:MaxGCPauseMillis </span><br></pre></td></tr></table></figure><h1 id="调整内存区域大小比率">4 调整内存区域大小比率</h1><p>现象：某一个区域的GC频繁，其他都正常。</p><p>原因：如果对应区域空间不足，导致需要频繁GC来释放空间，在JVM堆内存无法增加的情况下，可以调整对应区域的大小比率。</p><p>注意：也许并非空间不足，而是因为内存泄造成内存无法回收。从而导致GC频繁。</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//survivor区和Eden区大小比率</span></span><br><span class="line"> 指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//新生代和老年代的占比</span></span><br><span class="line"> -XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br></pre></td></tr></table></figure><h1 id="调整对象升老年代的年龄">5 调整对象升老年代的年龄</h1><p>现象：老年代频繁GC，每次回收的对象很多。</p><p>原因：如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时候可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁GC问题。</p><p>注意：增加了年龄之后，这些对象在新生代的时间会变长可能导致新生代的GC频率增加，并且频繁复制这些对象新生的GC时间也可能变长。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7</span></span><br><span class="line"> -XX:InitialTenuringThreshol=<span class="number">7</span> </span><br></pre></td></tr></table></figure><h1 id="调整大对象的标准">6 调整大对象的标准</h1><p>现象：老年代频繁GC，每次回收的对象很多,而且单个对象的体积都比较大。</p><p>原因：如果大量的大对象直接分配到老年代，导致老年代容易被填满而造成频繁GC，可设置对象直接进入老年代的标准。</p><p>注意：这些大对象进入新生代后可能会使新生代的GC频率和时间增加。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。</span></span><br><span class="line">  -XX:PretenureSizeThreshold=<span class="number">1000000</span> </span><br></pre></td></tr></table></figure><h1 id="调整gc触发时机">7 调整GC触发时机</h1><p>现象：CMS，G1 经常 Full GC，程序卡顿严重。</p><p>原因：G1和CMS  部分GC阶段是并发进行的，业务线程和垃圾收集线程一起工作，也就说明垃圾收集的过程中业务线程会生成新的对象，所以在GC的时候需要预留一部分内存空间来容纳新产生的对象，如果这个时候内存空间不足以容纳新产生的对象，那么JVM就会停止并发收集暂停所有业务线程（STW）来保证垃圾收集的正常运行。这个时候可以调整GC触发的时机（比如在老年代占用60%就触发GC），这样就可以预留足够的空间来让业务线程创建的对象有足够的空间分配。</p><p>注意：提早触发GC会增加老年代GC的频率。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小</span></span><br><span class="line"> -XX:CMSInitiatingOccupancyFraction</span><br><span class="line"></span><br><span class="line"> <span class="comment">//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%</span></span><br><span class="line"> -XX:G1MixedGCLiveThresholdPercent=<span class="number">65</span> </span><br></pre></td></tr></table></figure><h1 id="调整jvm本地内存大小">8 调整JVM本地内存大小</h1><p>现象：GC的次数、时间和回收的对象都正常，堆内存空间充足，但是报OOM</p><p>原因：JVM除了堆内存之外还有一块堆外内存，这片内存也叫本地内存，可是这块内存区域不足了并不会主动触发GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报OOM异常。</p><p>注意：本地内存异常的时候除了上面的现象之外，异常信息可能是OutOfMemoryError：Direct buffer memory。解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发GC（System.gc()）。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:MaxDirectMemorySize</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM GC原理认知</title>
      <link href="/2022/03/23/JVM-GC%E5%8E%9F%E7%90%86%E8%AE%A4%E7%9F%A5/"/>
      <url>/2022/03/23/JVM-GC%E5%8E%9F%E7%90%86%E8%AE%A4%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是jvm-gc">1、什么是JVM GC</h1><p><strong>JAVA GC</strong>（Garbage Collection，垃圾回收）机制是区别C++的一个重要特征，C++需要开发者自己实现垃圾回收的逻辑，而JAVA开发者则只需要专注于业务开发，因为垃圾回收这件繁琐的事情JVM已经为我们代劳了，从这一点上来说，JAVA还是要做的比较完善一些。但这并不意味着我们不用去理解GC机制的原理，因为如果不了解其原理，可能会引发内存泄漏、频繁GC导致应用卡顿,甚至出现OOM等问题，因此我们需要深入理解其原理，才能编写出高性能的应用程序，解决性能瓶颈。</p><p>       想要理解GC的原理，我们必须先理解JVM内存管理机制，因为这样我们才能知道回收哪些对象、什么时候回收以及怎么回收。</p><h1 id="jvm内存管理">2、JVM内存管理</h1><p>根据JVM规范，JVM把内存划分成了如下几个区域：</p><p>1.方法区（Method Area） 2.堆区（Heap） 3.虚拟机栈（VM Stack） 4.本地方法栈（Native Method Stack） 5.程序计数器（Program Counter Register）</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240039009.jpg" title="" alt="" data-align="center"></p><p>其中，方法区和堆所有线程共享。</p><h2 id="方法区method-area">2.1 方法区（Method Area）</h2><p>       方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。</p><p>       在Hotspot虚拟机中，这块区域对应<strong>持久代（Permanent Generation）</strong>，一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在方法区上进行GC，条件相当苛刻而且困难。</p><p>       运行时常量池（Runtime Constant Pool) 是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</p><h2 id="堆区heap">2.2 堆区（Heap）</h2><p>       堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</p><h2 id="虚拟机栈vm-stack">2.3 虚拟机栈（VM Stack）</h2><p>       虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个<strong>栈帧（Statck Frame）</strong>，栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。</p><p>       <strong>局部变量表</strong>中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变。</p><p>       虚拟机栈定义了两种<strong>异常类型</strong>：<strong>StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）</strong>。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</p><h2 id="本地方法栈native-method-stack">2.4 本地方法栈（Native Method Stack）</h2><p>       <strong>本地方法栈</strong>用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</p><h2 id="程序计数器program-counter-register">2.5 程序计数器（Program Counter Register）</h2><p>       <strong>程序计数器</strong>是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。</p><p>       每个程序计数器只能记录一个线程的行号，因此它是线程私有的。</p><p>       如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空，此内存区是唯一不会抛出OutOfMemoryError的区域。</p><h1 id="gc机制">3、GC机制</h1><p>       随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。</p><p>       在上面介绍的五个内存区域中，有3个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。</p><h2 id="查找算法">3.1 查找算法</h2><p>        经典的<strong>引用计数算法</strong>，每个对象添加到引用计数器，每被引用一次，计数器+1，失去引用，计数器-1，当计数器在一段时间内为0时，即认为该对象可以被回收了。但是这个算法有个明显的缺陷：当两个对象相互引用，但是二者都已经没有作用时，理应把它们都回收，但是由于它们相互引用，不符合垃圾回收的条件，所以就导致无法处理掉这一块内存区域。因此，Sun的JVM并没有采用这种算法，而是采用一个叫——<strong>根搜索算法</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240044073.jpg" title="" alt="" data-align="center"></p><p>基本思想是：从一个叫GC Roots的根节点出发，向下搜索，如果一个对象不能达到GC Roots的时候，说明该对象不再被引用，可以被回收。如上图中的Object5、Object6、Object7，虽然它们三个依然相互引用，但是它们其实已经没有作用了，这样就解决了引用计数算法的缺陷。</p><p>       补充概念，在JDK1.2之后引入了四个概念：<strong>强引用、软引用、弱引用、虚引用</strong>。<br />       <strong>强引用</strong>：new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常。<br />       <strong>软引用</strong>：只有当JVM内存不足时才会被回收。<br />       <strong>弱引用</strong>：只要GC,就会立马回收，不管内存是否充足。<br />       <strong>虚引用</strong>：可以忽略不计，JVM完全不会在乎虚引用，你可以理解为它是来凑数的，凑够”四大天王”。它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用。</p><p>       最后总结，什么样的类需要被回收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.该类的所有实例都已经被回收；</span><br><span class="line">b.加载该类的ClassLoad已经被回收；</span><br><span class="line">c.该类对应的反射类java.lang.Class对象没有被任何地方引用。</span><br></pre></td></tr></table></figure><h2 id="内存分区">3.2 内存分区</h2><p>       内存主要被分为三块：<strong>新生代（Youn Generation）、旧生代（Old Generation）、持久代（Permanent Generation）</strong>。三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，旧生代适合生命周期较长的对象，持久代在Sun Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240045706.jpg" title="" alt="" data-align="center"></p><p> <strong>新生代（Youn Generation）</strong>：大致分为Eden区和Survivor区，Survivor区又分为大小相同的两部分：FromSpace和ToSpace。新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区。当新生代进行垃圾回收时会出发<strong>Minor GC</strong>（也称作<strong>Youn GC</strong>）。</p><p>       <strong>旧生代（Old Generation）</strong>：旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC（也称作Full GC）。</p><p>       <strong>持久代（Permanent Generation）</strong>：在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代。</p><h2 id="gc算法">3.3 GC算法</h2><p>       <strong>常见的GC算法</strong>：<strong>复制、标记-清除和标记-压缩</strong></p><p>       <strong>复制</strong>：复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240047838.jpg" title="" alt="" data-align="center"></p><p>当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动。</p><p>       <strong>标记-清除</strong>：该算法采用的方式是从跟集合开始扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，并进行清除。标记和清除的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240048202.jpg" title="" alt="" data-align="center"></p><p>上图中蓝色部分是有被引用的对象，褐色部分是没有被引用的对象。在Marking阶段，需要进行全盘扫描，这个过程是比较耗时的。</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240048602.jpg" title="" alt="" data-align="center"></p><p>清除阶段清理的是没有被引用的对象，存活的对象被保留。</p><p>标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片。</p><p>       <strong>标记-压缩</strong>：该算法与标记-清除算法类似，都是先对存活的对象进行标记，但是在清除后会把活的对象向左端空闲空间移动，然后再更新其引用对象的指针，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures@main/imgs/202203240050963.jpg" title="" alt="" data-align="center"></p><p>由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）</p><h1 id="垃圾收集器">4、垃圾收集器</h1><p>       在JVM中，GC是由垃圾回收器来执行，所以，在实际应用场景中，我们需要选择合适的垃圾收集器，下面我们介绍一下垃圾收集器。</p><h2 id="串行收集器serial-gc">4.1 串行收集器（Serial GC）</h2><p>       <strong>Serial GC</strong>是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA SE6中客户端虚拟机采用的默认配置。比较适合于只有一个处理器的系统。在串行处理器中minor和major GC过程都是用一个线程进行回收的。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，而且事实上，它并没有让我们失望，几十毫秒的停顿，对于我们客户机是完全可以接受的，该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上，是client级别的默认GC方式。</p><h2 id="parnew-gc">4.2 ParNew GC</h2><p>       基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用于服务端上（server），同时它可以与CMS GC配合，所以，更加有理由将他用于server端。</p><h2 id="parallel-scavenge-gc">4.3 Parallel Scavenge GC</h2><p>       在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。</p><h2 id="cms-concurrent-mark-sweep收集器">4.4 CMS (Concurrent Mark Sweep)收集器</h2><p>       该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的。</p><p>CMS收集器的优点：并发收集、低停顿，但远没有达到完美；</p><p>CMS收集器的缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。</span><br><span class="line">b.CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。</span><br><span class="line">c.CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</span><br></pre></td></tr></table></figure><h2 id="g1收集器">4.5 G1收集器</h2><p>       相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。</p><h2 id="serial-old收集器">4.6 Serial Old收集器</h2><p> Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。</p><h2 id="parallel-old收集器">4.7 Parallel Old收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><h2 id="rtsj垃圾收集器">4.8 RTSJ垃圾收集器</h2><p>RTSJ垃圾收集器，用于Java实时编程。</p><h1 id="总结">5、总结</h1><p>       深入理解JVM的内存模型和GC机制有助于帮助我们编写高性能代码和提供代码优化的思路与方向。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内知名技术团队博客汇总</title>
      <link href="/2022/03/20/%E5%9B%BD%E5%86%85%E7%9F%A5%E5%90%8D%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/"/>
      <url>/2022/03/20/%E5%9B%BD%E5%86%85%E7%9F%A5%E5%90%8D%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<table><thead><tr class="header"><th><strong>名称</strong></th><th><strong>链接</strong></th></tr></thead><tbody><tr class="odd"><td>美团点评技术团队</td><td><a href="https://link.jianshu.com/?t=http://tech.meituan.com/">http://tech.meituan.com/</a></td></tr><tr class="even"><td>Tencent AlloyTeam</td><td><a href="https://link.jianshu.com/?t=http://www.alloyteam.com/">http://www.alloyteam.com/</a></td></tr><tr class="odd"><td>Tencent TG ideas</td><td><a href="https://link.jianshu.com/?t=http://tgideas.qq.com/">http://tgideas.qq.com/</a></td></tr><tr class="even"><td>WeRead团队博客</td><td><a href="https://link.jianshu.com/?t=http://wereadteam.github.io/">http://wereadteam.github.io/</a></td></tr><tr class="odd"><td>百度MUX</td><td><a href="https://link.jianshu.com/?t=http://mux.baidu.com/">http://mux.baidu.com</a></td></tr><tr class="even"><td>i flym</td><td><a href="https://link.jianshu.com/?t=https://www.iflym.com/">https://www.iflym.com/</a></td></tr><tr class="odd"><td>limboy</td><td><a href="https://link.jianshu.com/?t=http://limboy.me/">http://limboy.me/</a></td></tr><tr class="even"><td>老谭笔记</td><td><a href="https://link.jianshu.com/?t=http://www.tanhao.me/">http://www.tanhao.me/</a></td></tr><tr class="odd"><td>fengjian</td><td><a href="https://link.jianshu.com/?t=http://fengjian0106.github.io/">http://fengjian0106.github.io/</a></td></tr><tr class="even"><td>董铂然的博客</td><td><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/dsxniubility/">http://www.cnblogs.com/dsxniubility/</a></td></tr><tr class="odd"><td>ObjC中国</td><td><a href="https://link.jianshu.com/?t=https://objccn.io/issues/">https://objccn.io/issues/</a></td></tr><tr class="even"><td>iOS Blog</td><td><a href="https://link.jianshu.com/?t=http://www.ios-blog.co.uk/">http://www.ios-blog.co.uk/</a></td></tr><tr class="odd"><td>raywenderlich</td><td><a href="https://link.jianshu.com/?t=https://www.raywenderlich.com/">https://www.raywenderlich.com/</a></td></tr><tr class="even"><td>cocoa control</td><td><a href="https://link.jianshu.com/?t=https://www.cocoacontrols.com/platforms/ios/controls?page=2">https://www.cocoacontrols.com/platforms/ios/controls?page=2</a></td></tr><tr class="odd"><td>深入理解MyBatis原理</td><td><a href="https://link.jianshu.com/?t=http://blog.csdn.net/column/details/mybatis-principle.html">http://blog.csdn.net/column/details/mybatis-principle.html</a></td></tr><tr class="even"><td>踏雪无痕</td><td><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/chenpingzhao/default.html?page=1">http://www.cnblogs.com/chenpingzhao/default.html?page=1</a></td></tr><tr class="odd"><td>写点什么</td><td><a href="https://link.jianshu.com/?t=http://hongjiang.info/">http://hongjiang.info/</a></td></tr><tr class="even"><td>舒の随想日记</td><td><a href="https://link.jianshu.com/?t=http://blog.hesey.net/">http://blog.hesey.net/</a></td></tr><tr class="odd"><td>心静志远</td><td><a href="https://link.jianshu.com/?t=http://www.yanmingming.net/">http://www.yanmingming.net/</a></td></tr><tr class="even"><td>老码农的专栏</td><td><a href="https://link.jianshu.com/?t=http://blog.csdn.net/chen77716/article/details/387828">http://blog.csdn.net/chen77716/article/details/387828</a></td></tr><tr class="odd"><td>ian博客</td><td><a href="https://link.jianshu.com/?t=https://www.ianisme.com/">https://www.ianisme.com/</a></td></tr><tr class="even"><td>kaitiren</td><td><a href="https://link.jianshu.com/?t=http://my.csdn.net/Kaitiren">http://my.csdn.net/Kaitiren</a></td></tr><tr class="odd"><td>Jamin’s blog</td><td><a href="https://link.jianshu.com/?t=http://oncenote.com/">http://oncenote.com/</a></td></tr><tr class="even"><td>跳刀的兔子</td><td><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/shipengzhi/default.html?page=1">http://www.cnblogs.com/shipengzhi/default.html?page=1</a></td></tr><tr class="odd"><td>上善若水</td><td><a href="https://link.jianshu.com/?t=http://www.blogjava.net/DLevin/category/50406.html">http://www.blogjava.net/DLevin/category/50406.html</a></td></tr><tr class="even"><td>mybatis系列</td><td><a href="https://link.jianshu.com/?t=http://blog.csdn.net/hupanfeng/article/category/1443955">http://blog.csdn.net/hupanfeng/article/category/1443955</a></td></tr><tr class="odd"><td>正明</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/wensong8">http://weibo.com/wensong8</a></td></tr><tr class="even"><td>正祥（阳振坤） OceanBase项目负责人</td><td><a href="https://link.jianshu.com/?t=http://blog.sina.com.cn/kern0612">http://blog.sina.com.cn/kern0612</a></td></tr><tr class="odd"><td>毕玄（林昊） 集团核心系统资深技术专家</td><td><a href="https://link.jianshu.com/?t=http://www.blogjava.net/BlueDavy">http://</a><a href="https://link.jianshu.com/?t=http://www.blogjava.net/BlueDavy">www.blogjava.net/BlueDavy</a></td></tr><tr class="even"><td>放翁（岑文初） 淘宝开放平台项目负责人</td><td><a href="https://link.jianshu.com/?t=http://www.blogjava.net/cenwenchu/">http://www.blogjava.net/cenwenchu/</a></td></tr><tr class="odd"><td>小黑（吴翰清） 阿里云集团信息安全中心高级安全专家</td><td><a href="https://link.jianshu.com/?t=http://www.alidata.org/archives/author/yunzheng">http://www.alidata.org/archives/author/yunzheng</a></td></tr><tr class="even"><td>云铮（张清） 数据平台与产品部资深技术专家</td><td><a href="https://link.jianshu.com/?t=http://www.alidata.org/archives/author/yunzheng">http://www.alidata.org/archives/author/yunzheng</a></td></tr><tr class="odd"><td>华黎（曾宪杰） 淘宝技术委员会Java分会会长</td><td><a href="https://link.jianshu.com/?t=http://blogjava.net/vanadies10">http://blogjava.net/vanadies10</a></td></tr><tr class="even"><td>行癫 阿里副总裁，聚划算负责人</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/u/1419403675">http://weibo.com/u/1419403675</a></td></tr><tr class="odd"><td>七公（汪海） 淘宝网数据的掌门人</td><td><a href="https://link.jianshu.com/?t=http://www.alidata.org/archives/author/qigong">http://</a><a href="https://link.jianshu.com/?t=http://www.alidata.org/archives/author/qigong">www.alidata.org/archives/author/qigong</a></td></tr><tr class="even"><td>三丰 淘宝总裁</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/u/1400020414">http://weibo.com/u/1400020414</a></td></tr><tr class="odd"><td>冯大辉 DBA</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/fenng">http://weibo.com/fenng</a></td></tr><tr class="even"><td>淘宝褚霸</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/tchuba">http://weibo.com/tchuba</a></td></tr><tr class="odd"><td>拖雷 淘宝首席DBA</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/chenpiner">http://weibo.com/chenpiner</a></td></tr><tr class="even"><td>青云 淘宝首席交互设计师</td><td><a href="https://link.jianshu.com/?t=http://ued.taobao.org/blog/author/qingyun/">http://ued.taobao.org/blog/author/qingyun/</a></td></tr><tr class="odd"><td>玉伯 淘宝首席前端架构师</td><td><a href="https://link.jianshu.com/?t=http://weibo.com/lifesinger">http://weibo.com/lifesinger</a></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 技术站点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 双亲委派模型</title>
      <link href="/2022/03/17/JVM-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/03/17/JVM-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在了解双亲委派模型之前先来看看以下程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这是一段执行报错的程序，运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><p>我们都知道，各个类加载器都有自己加载的范围，比如引导类加载器只加载Java核心库中的class如String，那如果用户自己建一个包名和类名与String相同的类，会不会被引导类加载器加载。通过上述执行结果中的报错信息可以发现，JVM实际上加载了rt.jar中的String类，并未加载自定义的String，这个就是JVM的双亲委派模型解决的问题之一。</p><h1 id="双亲委派模型是什么">1 双亲委派模型是什么</h1><p>JVM对class文件是按需加载，在加载class的过程，如果当前类加载器存在父类加载器，都会将加载请求先委派给父类加载器，这种任务委派方式被称为双亲委派。</p><h1 id="双亲委派模型的工作原理">2 双亲委派模型的工作原理</h1><p>类加载器之间存在非继承的层次关系（如下图），这种层次关系让类加载器加载的类也具有优先级，也就是前面示例中rt.jar中的String优于自定义String的加载，这种优先级加载详细原理如下：</p><ul><li>当一个类加载器收到加载请求，他并不会自己加载，而是把加载请求委托给父类加载器。</li><li>如果父类加载器也存在父类加载器，继续向上委托，如此递归，直至最顶层引导类加载器。</li><li>如果父类加载器能完成类的加载，就正常返回，反之，由子类进行加载，递归依次向下。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures/imgs/class_loader_picture.png" title="" alt="alt  双亲委派模型图" data-align="center"></p><h1 id="双亲委派模型的优点">3 双亲委派模型的优点</h1><ul><li>避免全限定名相同的类被重复加载，导致程序异常。</li><li>保护程序，防止核心库API被篡改。</li></ul><h1 id="源码">4 源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 实现委派</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="如何打破双亲委派模型">5 如何打破双亲委派模型</h1><p>SPI(Service Provider Interface)，是一种服务发现机制，它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类，如JDBC驱动。如下图，SPI核心类定义在rt.jar中（如java.lang.Driver接口），所以本身是由启动类加载器加载，当调用SPI接口的实现类时，启动类加载器是无法加载实现类的，这个时候就提供了线程上下文类加载器(Thread Context ClassLoader)加载实现类，ThreadContextClassLoader是可以通过java.lang.Thread#setContextClassLoader方法设置，如果没有设置默认为ApplicationClassLoader,这样双亲委派模型中ApplicationClassLoader-&gt;BootStrapClassLoader的委派，变成了BootStrapClassLoader-&gt;ApplicationClassLoader的委派，这样就打破了双亲委派的类加载模式。</p><figure><img src="https://cdn.jsdelivr.net/gh/wangjie-lang/blog_pictures/imgs/break_class_loader_pic.png" alt="alt SPI架构图" /><figcaption aria-hidden="true">alt SPI架构图</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Huffman编码实现图片的无损压缩</title>
      <link href="/2022/02/14/Huffman%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/02/14/Huffman%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-什么是huffman树">一、 什么是Huffman树</h1><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，也叫Huffman树。在构建Huffman树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。</p><h1 id="二huffman树有什么用">二、Huffman树有什么用？</h1><p> 对于一组具有确定权值的叶子结点，可以构造出多个具有不同带权路径长度的二叉树，我们把其中最小带权路径长度的二叉树称为Huffman树（最优二叉树），Huffman树可以用于构造代码长度最短的编码，因此我们常用Huffman树实现文件压缩。</p><h1 id="三huffman实现图片压缩的流程">三、Huffman实现图片压缩的流程</h1><ul><li><p>读原文件，获得权值列表，生成哈夫曼树，遍历树生成哈夫曼编码。</p></li><li><p>写入压缩文件，后缀.huf，先写入文件头（包括文件类型，权值列表，文件长度，以便于从压缩文件中再次生成哈夫曼编码来解压，也可以用其他的方式，比如直接将哈夫曼编码以先序遍历的方式写入压缩文件的开始，代码中有体现）。</p></li><li><p>将原文件编码后写入压缩文件。</p></li><li><p>读取压缩文件，生成哈夫曼树，每次读取到0则向左子树移动，读取到1向右子树移动，直到遇到叶子结点，将叶子结点存储的编码写入解压文件。</p></li><li><p>值得注意的的是，权值数组的运作。图片文件按二进制读取，一个字节一个字节读，那么每个字节有8位二进制，则用unsigned char读取，最多只会有0～255种可能的值，即权值数组的大小设成256。</p></li><li><p>数据结构并没有使用真正意义上的树，即包括指向结点的指针，而使用一个结点数组来保存树，结点中存储的左右孩子和双亲都是数组下标。Huffman树的一个性质是总结点数 = 叶子结点数 * 2 - 1，这样得到了开辟的存储树的数组大小。</p></li><li><p>其中用Huffman编码将原文件编码时，不能直接将编码（0101…)按1个char（即一个字节的大小）存1位编码来写入压缩文件，否则文件反而会变更大，而是用1个char的8位（即1byte中的8bits）来存8位的编码。在代码中有BitIO.h专门定义了做这些位运算的结构和函数，也有HuffmanTree.h中定义了Str2Byte函数，也有#define定义的GET_BYTE等函数。这三处功能是基本相同的，实现各有不同，这里我使用的是较简单Str2Byte。</p></li></ul><h1 id="四源码">四、源码</h1><p><strong>BitIO.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUFFMANCOMPRESSCPRO1_BITIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUFFMANCOMPRESSCPRO1_BITIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITBUFFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> b[BITBUFFSIZE];<span class="comment">//位数组 bit数组</span></span><br><span class="line">    <span class="keyword">int</span> p; <span class="comment">//指示数组填到哪一位的下一位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向位数组栈顶推入一位</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushBit</span><span class="params">(BIT *buffer, <span class="keyword">const</span> <span class="keyword">bool</span> istrue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从文件加载多位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fPushBit</span><span class="params">(BIT* buffer, FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改position位置的一位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changeBit</span><span class="params">(BIT* buffer, <span class="keyword">const</span> <span class="keyword">int</span> istrue, <span class="keyword">const</span> <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readBit</span><span class="params">(BIT* buffer, <span class="keyword">const</span> <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶弹出一位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popBit</span><span class="params">(BIT* buffer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//HUFFMANCOMPRESSCPRO1_BITIO_H</span></span></span><br></pre></td></tr></table></figure><p><strong>BitIO.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BitIO.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushBit</span><span class="params">(BIT *buffer, <span class="keyword">const</span> <span class="keyword">bool</span> istrue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer-&gt;p &gt;= BITBUFFSIZE * <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(istrue)</span><br><span class="line">        buffer-&gt;b[buffer-&gt;p &gt;&gt; SHIFT] |= <span class="number">128u</span> &gt;&gt; buffer -&gt; p % <span class="number">8</span>; <span class="comment">//p所指位置填1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer-&gt;b[buffer-&gt;p &gt;&gt; SHIFT] &amp;= ~(<span class="number">128u</span> &gt;&gt; buffer -&gt; p % <span class="number">8</span>); <span class="comment">//p所指位置填0</span></span><br><span class="line">    buffer-&gt;p++;</span><br><span class="line">    <span class="keyword">return</span> istrue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fPushBit</span><span class="params">(BIT* buffer, FILE* fp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(BIT));</span><br><span class="line">    <span class="keyword">if</span>(buffer -&gt; p = <span class="built_in">fread</span>(buffer-&gt;b, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), BITBUFFSIZE, fp) &amp;&amp; <span class="built_in">feof</span>(fp))&#123;</span><br><span class="line">        buffer-&gt;p = (buffer-&gt;p - <span class="number">2</span>) * <span class="number">8</span> + buffer -&gt; b[buffer -&gt; p - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        buffer -&gt; p *= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer -&gt; p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changeBit</span><span class="params">(BIT* buffer, <span class="keyword">const</span> <span class="keyword">int</span> istrue, <span class="keyword">const</span> <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position &gt;= buffer -&gt; p)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (istrue)</span><br><span class="line">        buffer -&gt; b[position &gt;&gt; SHIFT] |= <span class="number">128u</span> &gt;&gt; position % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer -&gt; b[position &gt;&gt; SHIFT] &amp;= ~(<span class="number">128u</span> &gt;&gt; position % <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> istrue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readBit</span><span class="params">(BIT* buffer, <span class="keyword">const</span> <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position &gt;= buffer -&gt; p)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> buffer-&gt;b[position &gt;&gt; SHIFT] &amp; (<span class="number">128u</span> &gt;&gt; position % <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popBit</span><span class="params">(BIT* buffer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer -&gt; p &gt;= BITBUFFSIZE || buffer -&gt; p &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    buffer-&gt;p--;</span><br><span class="line">    <span class="keyword">return</span> buffer-&gt;b[(buffer-&gt;p + <span class="number">1</span>) &gt;&gt; SHIFT] &amp; (<span class="number">128u</span> &gt;&gt; (buffer-&gt;p + <span class="number">1</span>) % <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HuffmanTree.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUFFMANCOMPRESSCPRO1_HUFFMANTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUFFMANCOMPRESSCPRO1_HUFFMANTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BitIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODES 2*SIZE - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各种各样的编码方法</span></span><br><span class="line"><span class="comment">//取出index位，若取出的index位为0，则GET_BYTE值为假，否则为真</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BYTE(vByte, index) (((vByte) &amp; (1 &lt;&lt; ((index) ^ 7))) != 0)</span></span><br><span class="line"><span class="comment">//把index位设置为‘1’</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BYTE(vbyte, index) ((vbyte) |= (1 &lt;&lt; ((index) ^ 7)))</span></span><br><span class="line"><span class="comment">//把index位设置为‘0’</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR_BYTE(vbyte, index) ((vbyte) &amp;= (~(1 &lt;&lt; ((index) ^ 7))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//n个叶子结点的哈夫曼树共有2n-1个结点</span></span><br><span class="line"><span class="comment">//一个字节8位 读取文件的char可以从0-255 用weight[]数组记录每个char出现的频率</span></span><br><span class="line"><span class="comment">//HuffmanTree 保存在HTNode[2n-1]的数组中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lChild = <span class="number">0</span>, rChild = <span class="number">0</span>, parent = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Node HTNode, *HuffTree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HEAD</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> weight[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffTree HT, <span class="keyword">int</span> end, <span class="keyword">int</span>* s1, <span class="keyword">int</span>* s2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(std::string st[], Node x, std::string s, HuffTree HT)</span></span>;</span><br><span class="line"><span class="function">std::string* <span class="title">buildCode</span><span class="params">(Node root, HuffTree HT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBuildCode</span><span class="params">(std::string* st)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTrie</span><span class="params">(<span class="keyword">int</span> *w, HuffTree&amp; HT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>* w, HuffTree&amp; HT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBuildTrie</span><span class="params">(<span class="keyword">int</span> *w, HuffTree HT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHead</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Filename, HEAD&amp; sHead)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Str2Byte</span><span class="params">(<span class="keyword">char</span>* BinStr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x, FILE* fpo, HuffTree&amp; HT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(FILE* fpi, FILE* fpo, std::string* st)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeHead</span><span class="params">(FILE* fpo, HEAD&amp; head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Extract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//HUFFMANCOMPRESSCPRO1_HUFFMANTREE_H</span></span></span><br></pre></td></tr></table></figure><p><strong>HuffmanTree.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HuffmanTree.h&quot;</span></span></span><br><span class="line"><span class="comment">//HT指向HuffmanTree end为保存树数组所需搜寻的末尾，s1，s2分别指向最小和次小结点在树数组中下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffTree HT, <span class="keyword">int</span> end, <span class="keyword">int</span>* s1, <span class="keyword">int</span>* s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min1, min2;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        <span class="comment">//找到第一个无双亲结点</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min1 = HT[i].weight;</span><br><span class="line">    *s1 = i;</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        <span class="comment">//第二个无双亲结点</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HT[i].weight &lt; min1)&#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        min1 = HT[i].weight;</span><br><span class="line">        *s2 = *s1;</span><br><span class="line">        *s1 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        min2 = HT[i].weight;</span><br><span class="line">        *s2 = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= end; j++)&#123;</span><br><span class="line">        <span class="comment">//两结点与后续无双亲结点比较</span></span><br><span class="line">        <span class="keyword">if</span>(HT[j].parent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HT[j].weight &lt; min1)&#123;</span><br><span class="line">            <span class="comment">//新结点小于min1</span></span><br><span class="line">            min2 = min1;</span><br><span class="line">            *s2 = *s1;</span><br><span class="line">            min1 = HT[j].weight;</span><br><span class="line">            *s1 = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123;</span><br><span class="line">            <span class="comment">//新结点介于min1，min2 之间</span></span><br><span class="line">            min2 = HT[j].weight;</span><br><span class="line">            *s2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTrie</span><span class="params">(<span class="keyword">int</span> *w, HuffTree&amp; HT)</span></span>&#123;</span><br><span class="line">    HT = (HuffTree) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(HTNode) * NODES);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">        <span class="comment">//0-255 叶子结点</span></span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].rChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].lChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].ch = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE; i &lt; NODES; i++)&#123;</span><br><span class="line">        <span class="comment">//256-510 内部结点</span></span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].ch = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>* w, HuffTree&amp; HT)</span></span>&#123;</span><br><span class="line">    <span class="comment">//每次搜寻两棵频率最小的树合并</span></span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = SIZE; i &lt; NODES; i++)&#123;</span><br><span class="line">        <span class="comment">//从256开始填树结点，一直到把根结点510填满 NODES = 511</span></span><br><span class="line">        <span class="built_in">select</span>(HT, i - <span class="number">1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        HT[s1].parent = HT[s2].parent = i;</span><br><span class="line">        HT[i].lChild = s1;</span><br><span class="line">        HT[i].rChild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBuildTrie</span><span class="params">(<span class="keyword">int</span> *w, HuffTree HT)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;字节ASCII &quot;</span>&lt;&lt;<span class="string">&quot;频率&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//文件中出现的字节对应的ASCII（十六进制）和 出现的频率</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02X %d\n&quot;</span>,i, w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哈夫曼树中所有结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结点下标\t频率\t双亲下标\t左孩子下标\t右孩子下标\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODES; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HT[%d]\t%d\t%d  \t%d  \t\t%d\t%d\n&quot;</span>, i, HT[i].weight, HT[i].parent, HT[i].lChild, HT[i].rChild,HT[i].ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Node::isLeaf</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> lChild == <span class="number">0</span> &amp;&amp; rChild == <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(std::string st[], Node x, std::string s, HuffTree HT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">isLeaf</span>())&#123;</span><br><span class="line">        st[x.ch] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buildCode</span>(st, HT[x.lChild], s + <span class="string">&#x27;0&#x27;</span>, HT);</span><br><span class="line">    <span class="built_in">buildCode</span>(st, HT[x.rChild], s + <span class="string">&#x27;1&#x27;</span>, HT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string* <span class="title">buildCode</span><span class="params">(Node root, HuffTree HT)</span></span>&#123;</span><br><span class="line">    std::string st[SIZE];</span><br><span class="line">    <span class="built_in">buildCode</span>(st, root, <span class="string">&quot;&quot;</span>, HT);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HuffmanCode: &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Bytes \t Codes&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02X :&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,st[i].<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBuildCode</span><span class="params">(std::string* st)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HuffmanCode: &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Bytes \t Codes&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02X :&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(st+i)-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHead</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Filename, HEAD&amp; sHead)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化文件头</span></span><br><span class="line">    <span class="keyword">char</span>* t = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="built_in">strlen</span>(Filename));</span><br><span class="line">    <span class="built_in">strcpy</span>(t,<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(Filename));</span><br><span class="line">    <span class="keyword">char</span>* token = std::<span class="built_in">strtok</span>(t, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    std::string str[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        str[it++] = token;</span><br><span class="line">        token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> t2[<span class="number">8</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; str[it - <span class="number">1</span>].<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">        t2[k] = str[it - <span class="number">1</span>].<span class="built_in">at</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(sHead.type, t2);</span><br><span class="line">    sHead.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">        sHead.weight[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以二进制流打开文件</span></span><br><span class="line">    FILE* in = <span class="built_in">fopen</span>(Filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = <span class="built_in">fgetc</span>(in)) != EOF)&#123;</span><br><span class="line">        sHead.weight[ch]++;</span><br><span class="line">        sHead.length++;<span class="comment">//原文件长度多少字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(in);</span><br><span class="line">    in = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将8位char变成一个char 即把 char数组 中的 char01 变成 一个char 中的 位01</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">Str2Byte</span><span class="params">(<span class="keyword">char</span>* BinStr)</span></span>&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> b = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (BinStr[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = b | <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将编码好的单词查找树写在文件开头，代价是文件变大， 也可以利用文件头(上述HEAD)中的weight数组在解压时重新构建树</span></span><br><span class="line"><span class="comment">//按位写入查找树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x, FILE* fpo, HuffTree&amp; HT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">isLeaf</span>())&#123;</span><br><span class="line">        <span class="keyword">bool</span> t = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">fwrite</span>(&amp;t,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>),<span class="number">1</span>,fpo);</span><br><span class="line">        ch = (<span class="keyword">char</span>)x.ch;</span><br><span class="line">        <span class="built_in">fwrite</span>(&amp;ch, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), <span class="number">1</span>, fpo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> t = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">fwrite</span>(&amp;t, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>), <span class="number">1</span>, fpo);</span><br><span class="line">    <span class="built_in">writeTrie</span>(HT[x.lChild], fpo, HT);</span><br><span class="line">    <span class="built_in">writeTrie</span>(HT[x.rChild], fpo, HT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原文件编码后写入压缩文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(FILE* fpi, FILE* fpo, std::string* st)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">char</span> cd[SIZE] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//unsigned char pBuffer[1000] = &#123;0&#125;; //debug</span></span><br><span class="line">    <span class="keyword">if</span>(!fpo)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;outFile opening failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((ch = <span class="built_in">fgetc</span>(fpi)) != EOF)&#123;</span><br><span class="line">        std::string code = st[ch];</span><br><span class="line">        <span class="built_in">strcat</span>(cd, code.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">strlen</span>(cd) &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> w = <span class="built_in">Str2Byte</span>(cd);</span><br><span class="line">            <span class="comment">//pBuffer[pos++] = w;</span></span><br><span class="line">            <span class="built_in">fwrite</span>(&amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), <span class="number">1</span>, fpo);<span class="comment">//写入文件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE - <span class="number">8</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//cd整体向左偏移8位</span></span><br><span class="line">                cd[i] = cd[i + <span class="number">8</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理可能剩余不足8位</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(cd) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> w = <span class="built_in">Str2Byte</span>(cd);</span><br><span class="line">        <span class="built_in">fwrite</span>(&amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), <span class="number">1</span>, fpo); <span class="comment">//最后不足8位的位都为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeHead</span><span class="params">(FILE* fpo, HEAD&amp; head)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fwrite</span>(&amp;head, <span class="built_in"><span class="keyword">sizeof</span></span>(head), <span class="number">1</span>, fpo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Extract</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;File to extract: &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> efile[<span class="number">256</span>];</span><br><span class="line">    std::cin&gt;&gt;efile;</span><br><span class="line">    FILE* in = <span class="built_in">fopen</span>(efile, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!in)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;File opening failed&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    HEAD head;</span><br><span class="line">    <span class="built_in">fread</span>(&amp;head, <span class="built_in"><span class="keyword">sizeof</span></span>(HEAD), <span class="number">1</span>, in);</span><br><span class="line">    <span class="keyword">char</span> file[SIZE] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* t = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="built_in">strlen</span>(efile));</span><br><span class="line">    <span class="built_in">strcpy</span>(t, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(efile));</span><br><span class="line">    <span class="keyword">char</span>* token = <span class="built_in">strtok</span>(t, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(file, token);</span><br><span class="line">    <span class="built_in">strcat</span>(file, <span class="string">&quot;_extracted.&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(file, head.type);</span><br><span class="line">    FILE* out = <span class="built_in">fopen</span>(file, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fseek</span>(in, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">long</span> filesize = <span class="built_in">ftell</span>(in);</span><br><span class="line"></span><br><span class="line">    HuffTree HT;</span><br><span class="line">    <span class="built_in">InitTrie</span>(head.weight, HT);</span><br><span class="line">    <span class="built_in">buildTrie</span>(head.weight, HT);</span><br><span class="line">    std::string st[SIZE];</span><br><span class="line">    <span class="built_in">buildCode</span>(st,HT[NODES<span class="number">-1</span>], <span class="string">&quot;&quot;</span>, HT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fseek</span>(in, <span class="number">1032</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">long</span> curLoc = <span class="built_in">ftell</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> outValue;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root = NODES - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ch = <span class="built_in">fgetc</span>(in);</span><br><span class="line">    <span class="built_in">fseek</span>(out, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HT[root].lChild == <span class="number">0</span> &amp;&amp; HT[root].rChild == <span class="number">0</span>)&#123;</span><br><span class="line">            outValue = (<span class="keyword">char</span>)HT[root].ch;</span><br><span class="line">            <span class="built_in">fwrite</span>(&amp;outValue, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), <span class="number">1</span>, out);</span><br><span class="line">            <span class="keyword">if</span>(curLoc &gt;= filesize)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = NODES - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(ch &amp; (<span class="number">1</span> &lt;&lt; (index ^ <span class="number">7</span>)))) &#123;</span><br><span class="line">            root = HT[root].lChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = HT[root].rChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(++index &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            ch = <span class="built_in">fgetc</span>(in);</span><br><span class="line">            curLoc = <span class="built_in">ftell</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(in);</span><br><span class="line">    <span class="built_in">fclose</span>(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Compress.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUFFMANCOMPRESSCPRO1_COMPRESS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUFFMANCOMPRESSCPRO1_COMPRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">char</span>* Filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//HUFFMANCOMPRESSCPRO1_COMPRESS_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Compress.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Compress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HuffmanTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">char</span>* Filename)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> weight[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE* fin = <span class="built_in">fopen</span>(Filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fin)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;File opening failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = <span class="built_in">fgetc</span>(fin)) != EOF)&#123;</span><br><span class="line">        weight[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fin);</span><br><span class="line"></span><br><span class="line">    HuffTree HT;</span><br><span class="line">    <span class="built_in">InitTrie</span>(weight, HT);</span><br><span class="line">    <span class="built_in">buildTrie</span>(weight, HT);</span><br><span class="line">    <span class="built_in">testBuildTrie</span>(weight, HT);</span><br><span class="line"></span><br><span class="line">    std::string st[SIZE];</span><br><span class="line">    <span class="built_in">buildCode</span>(st,HT[NODES<span class="number">-1</span>], <span class="string">&quot;&quot;</span>, HT);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HuffmanCode: &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Bytes \t Codes&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02X :&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,st[i].<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    HEAD head;</span><br><span class="line">    <span class="built_in">InitHead</span>(Filename, head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(filename, Filename);</span><br><span class="line">    <span class="built_in">strcat</span>(filename, <span class="string">&quot;.huf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FILE* out = <span class="built_in">fopen</span>(filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="built_in">writeHead</span>(out, head);</span><br><span class="line"></span><br><span class="line">    fin = <span class="built_in">fopen</span>(Filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="built_in">encode</span>(fin, out, st);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fin);</span><br><span class="line">    <span class="built_in">fclose</span>(out);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Extract</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HuffmanTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Compress.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;==== Huffman Compress &amp; Extract ====&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;filename: &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[SIZE];</span><br><span class="line">    cin&gt;&gt;filename;</span><br><span class="line">    <span class="built_in">Compress</span>(filename);<span class="comment">//解压函数也在这里运行了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对mvcc的实现原理的理解</title>
      <link href="/2022/02/09/mvcc%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/02/09/mvcc%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在数据库领域，面对高并发环境下数据冲突的问题，常用的解决方案有两种：</p><ol type="1"><li><p>想办法避免冲突。使用<strong>悲观锁</strong>来确保同一时刻只有一人能对数据进行更改，常见的实现有读写锁（Read/Write Locks）、两阶段锁（Two-Phase Locking）等。</p></li><li><p>允许冲突，但发生冲突的时候，要有能力检测到。这种方法被称为<strong>乐观锁</strong>，即先乐观的认为冲突不会发生，除非被证明（检测到）当前确实产生冲突了。常见的实现有逻辑时钟（Logical Clock）、MVCC（Multi-version Cocurrent Control）等。</p></li></ol><p>在这些解决方案中，MVCC 由于其出色的性能优势，而被越来越多的数据库所采用，比如Oracle、PostgreSQL、MySQL InnoDB、etcd 等。它的基本思想是保存一个数据的多个历史版本，从而解决事务管理中数据隔离的问题。</p><h1 id="什么是mvcc">1 什么是MVCC</h1><p>MVCC全称是： Multiversion concurrency control ，多版本并发控制，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。</p><p>假设，pA正在读数据库中某些内容，而pB正在给这些内容做修改（假设是在一个事务内修改，大概持续10s左右），A在这10s内 则可能看到一个不一致的数据，在B没有提交前，如何让A能够一直读到的数据都是一致的呢？</p><p>有几种处理方法，第一种：<br />基于锁的并发控制，程序员B开始修改数据时，给这些数据加上锁，程序员A这时再读，就发现读取不了，处于等待情况，只能等B操作完才能读数据，这保证A不会读到一个不一致的数据，但是这个会影响程序的运行效率。还有一种就是：MVCC，每个用户连接数据库时，看到的都是某一特定时刻的数据库快照，在B的事务没有提交之前，A始终读到的是某一特定时刻的数据库快照，不会读到B事务中的数据修改情况，直到B事务提交，才会读取B的修改内容。</p><p>一个支持MVCC的数据库，在更新某些数据时，并非使用新数据覆盖旧数据，而是标记旧数据是过时的，同时在其他地方新增一个数据版本。因此，同一份数据有多个版本存储，但只有一个是最新的。</p><p>MVCC提供了 时间一致性的<br />处理思路，在MVCC下读事务时，通常使用一个时间戳或者事务ID来确定访问哪个状态的数据库及哪些版本的数据。读事务跟写事务彼此是隔离开来的，彼此之间不会影响。假设同一份数据，既有读事务访问，又有写事务操作，实际上，写事务会新建一个新的数据版本，而读事务访问的是旧的数据版本，直到写事务提交，读事务才会访问到这个新的数据版本。</p><p>MVCC有两种实现方式，第一种实现方式是将数据记录的多个版本保存在数据库中，当这些不同版本数据不再需要时，垃圾收集器回收这些记录。这个方式被PostgreSQL和Firebird/Interbase采用，SQL</p><p>Server使用的类似机制，所不同的是旧版本数据不是保存在数据库中，而保存在不同于主数据库的另外一个数据库tempdb中。第二种实现方式只在数据库保存最新版本的数据，但是会在使用undo时动态重构旧版本数据，这种方式被Oracle和MySQL/InnoDB使用。</p><h1 id="innodb的mvcc实现机制">2、InnoDB的MVCC实现机制</h1><p>MVCC可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此开销更低。MVCC的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。InnoDB的MVCC实现，是通过保存数据在某个时间点的快照来实现的。</p><p>一个事务，不管其执行多长时间，其内部看到的数据是一致的。也就是事务在执行的过程中不会相互影响。下面我们简述一下MVCC在InnoDB中的实现。</p><p>InnoDB的MVCC， 通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间），当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增 。在RR隔离级别下，MVCC的操作如下：</p><ul><li>select操作。<br /></li><li>InnoDB只查找版本早于（包含等于）当前事务版本的数据行。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。<br /></li><li>行的删除版本要么未定义，要么大于当前事务版本号。可以确保事务读取的行，在事务开始之前未删除。<br /></li><li>insert操作。将新插入的行保存当前版本号为行版本号。<br /></li><li>delete操作。将删除的行保存当前版本号为删除标识。<br /></li><li>update操作。变为insert和delete操作的组合，insert的行保存当前版本号为行版本号，delete则保存当前版本号到原来的行作为删除标识。</li></ul><p>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除 ，这个过程叫做purge。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP之next数组的进阶算法</title>
      <link href="/2022/02/06/KMP%E4%B9%8Bnext%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/02/06/KMP%E4%B9%8Bnext%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>KMP算法是<strong>模式匹配</strong>专用算法。</p><p>它是在已知模式串的next或nextval数组的基础上执行的。</p><p>如果不知道它们二者之一，就没法使用KMP算法，因此我们需要计算它们。</p><p>KMP算法由两部分组成：</p><p>第一部分，计算模式串的next或nextval数组。</p><p>第二部分，利用计算好的模式串的nextval数组，进行模式匹配。</p><p>KMP算法中有next数组和nextval数组之分。 他们代表的意义和作用完全一样，完全可以混用。 唯一不同的是，next数组在一些情况下有些缺 陷，而nextval是为了弥补这个缺陷而产生的。</p><h1 id="一求解next数组">一、求解next数组</h1><p>next数组值的程序设计求解方法：首先可以肯定的是第一位的next值为0，第二位的next值为1，后面求解每一位的next值时，根据前一位 进行比较。首先将前一位与其next值对应的内容进行比较，如果相等，则该位的next值就是前一位的next值加上1；如果不等，向前继续寻找next值对应的内容来与前一位进行比较，直到找到某个位上内容的next值对应的内容与前一位相等为止，则这个位对应的值加上1即为需求的next值；如果找到 第一位都没有找到与前一位相等的内容，那么需求的位上的next值即为1。</p><p>举例：</p><p>模式串 a b a a b c a c</p><p>next值 0 1 1 2 2 3 1 2</p><p>1.前两位必为0，1。 2.计算第三位的时候，看第二位b的next值，为1，则把b和1对应的a进行比较，不同，则第三位a的next的值为1，因为一直比到最前一位，都没有发生比较相同的现象。</p><p>3.计算第四位的时候，看第三位a的next值，为1，则把a和1对应的a进行比较，相同，则第四位a的next的值为第三位a的next值加上1，为2。因为是在第三位实现了其next值对应<br />的值与第三位的值相同。</p><p>4.计算第五位的时候，看第四位a的next值，为2，则把a和2对应的b进行比较，不同，则再将b对应的next值1对应的a与第四位的a进行比较，相同，则第五位的next值为第二位b的next值加上1，为2。因为是在第二位实现了其next值对应的值与第四位的值相同。</p><p>5.计算第六位的时候，看第五位b的next值，为2，则把b和2对应的b进行比较，相同，则第六位c的next值为第五位b的next值加上1，为3，因为是在第五位实现了其next值对应的值与第五位相。</p><p>6.计算第七位的时候，看第六位c的next值，为3，则把c和3对应的a进行比较，不同，则再把第3位a的next值1对应的a与第六位c比较，仍然不同，则第七位的next值为1。</p><p>7.计算第八位的时候，看第七位a的next值，为1，则把a和1对应的a进行比较，相同，则第八位c的next值为第七位a的next值加上1，为2，因为是在第七位和实现了其next值对应的值与第七位相同。</p><h1 id="二求解nextval数组">二、求解nextval数组</h1><p>求nextval数组值有两种方法，一种是不依赖next数组值直接用观察法求得，一种方法是根据next数组值进行推理，两种方法均可使用，视更喜欢哪种方法而定。</p><p>本文主要分析nextval数组值的第二种方法：</p><p>模式串     a b a a b c a c</p><p>next值     0 1 1 2 2 3 1 2</p><p>nextval值 0 1 0 2 1 3 0 2</p><p>1.第一位的nextval值必定为0，第二位如果于第一位相同则为0，如果不同则为1。</p><p>2.第三位的next值为1，那么将第三位和第一位进行比较，均为a，相同，则，第三位的nextval值为0。</p><p>3.第四位的next值为2，那么将第四位和第二位进行比较，不同，则第四位的nextval值为其next值，为2。</p><p>4.第五位的next值为2，那么将第五位和第二位进行比较，相同，第二位的next值为1，则继续将第二位与第一位进行比较，不同，则第五 位的nextval值为第二位的next值，为1。 　　 5.第六位的next值为3，那么将第六位和第三位进行比较，不同，则第六位的nextval值为其next值，为3。</p><p>6.第七位的next值为1，那么将第七位和第一位进行比较，相同，则第七位的nextval值为0。 7.第八位的next值为2，那么将第八位和第二位进行比较，不同，则第八位的nextval值为其next值，为2。</p><h1 id="三next和nextval比较">三、next和nextval比较</h1><p>Next数组的缺陷举例如下：</p><p>比如主串是“aab…..” 省略号代表后面还有字符。</p><p>模式串“aac”</p><p>通过计算aac的next数组为012（另外，任何字符串的第二位字符的next总是1，因此你可以认为他固定为1）</p><p>当模式串在字符c上失配时，会跳到第2个字符，然后再和主串当前失配的字符重新比较，即此处用模式串的第二个a和主串的b比较</p><p>即 aab aac</p><p>显然a也不等于b。然后 会跳到1，接着比，然后又失配，直到最后才使主串后移一位。</p><p>而“aac”的nextval数组为002 当在c失配时会跳到2，若还失配就直接跳到0，比next数组少比较了1次。</p><p>在如果模式串很长的话，那可以省去很多比较，因此应该使用nextval数组。</p><h1 id="四代码实现java语言描述">四、代码实现（java语言描述）：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException</span>&#123;<span class="comment">//main函数，输入主串和模式串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入主串:&quot;</span>);</span><br><span class="line">        Scanner sn1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s1 = sn1.next();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入模式串:&quot;</span>);</span><br><span class="line">        Scanner sn2 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s2 = sn2.next();</span><br><span class="line">        <span class="keyword">char</span> [] s3 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> [] s4 = s2.toCharArray();</span><br><span class="line">        System.out.print(KMP_test(s3,s4));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMP_test</span><span class="params">(<span class="keyword">char</span> [] s, <span class="keyword">char</span> [] t)</span></span>&#123;<span class="comment">// 主串顺序匹配</span></span><br><span class="line">        <span class="keyword">int</span> [] next = next(t);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        wile(<span class="function">i</span></span><br><span class="line"><span class="function">            <span class="title">if</span><span class="params">(j == -<span class="number">1</span> || s[i] == t[j])</span></span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span>(j</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i-t.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] next(<span class="keyword">char</span> [] t)&#123;<span class="comment">// next函数求解</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="function">i</span></span><br><span class="line"><span class="function">            <span class="title">if</span><span class="params">(j == -<span class="number">1</span> || t[i] == t[j])</span></span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">对于改进的KMP算法，只需要把next函数换为nextval函数就行了</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] next(<span class="keyword">char</span> [] t)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="function">i</span></span><br><span class="line"><span class="function">            <span class="title">if</span><span class="params">(j == -<span class="number">1</span> || t[i] == t[j])</span></span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span> (t[i] != t[j]) &#123;  </span><br><span class="line">                    next[i] = j;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    next[i] = next[j];  </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程中的秩序维护者</title>
      <link href="/2022/01/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%A7%A9%E5%BA%8F%E7%BB%B4%E6%8A%A4%E8%80%85/"/>
      <url>/2022/01/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%A7%A9%E5%BA%8F%E7%BB%B4%E6%8A%A4%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>在并发编程中，经常遇到多个线程访问同一个<strong>共享资源</strong>，这时候作为开发者必须考虑如何维护数据一致性，在java中synchronized关键字被常用于维护数据一致性。synchronized机制是给共享资源上锁，只有拿到锁的线程才可以访问共享资源，这样就可以强制使得对共享资源的访问都是顺序的，因为对于共享资源属性访问是必要也是必须的。</p><p>那么在java中常见的锁类型有哪些呢？</p><h1 id="java锁的分类">1. Java锁的分类</h1><ul><li>乐观锁/悲观锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>可重入锁</li><li>公平锁/非公平锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h2 id="乐观锁悲观锁">1.1 乐观锁/悲观锁</h2><p>乐观锁与悲观锁并不是特指某两种类型的锁，是人们定义出来的概念或思想，主要是指看待并发同步的角度。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。</p><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。</p><p>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。</p><p>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h2 id="独享锁共享锁">1.2 独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>共享锁是指该锁可被多个线程所持有。</p><p>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类  ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</p><p>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>对于Synchronized而言，当然是独享锁。</p><h2 id="互斥锁读写锁">1.3 互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><p>互斥锁在Java中的具体实现就是ReentrantLock。</p><p>读写锁在Java中的具体实现就是ReadWriteLock。</p><h2 id="可重入锁">1.4 可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</p><p>对于Java ReetrantLock而言，从名字就可以看出是一个重入锁，其名字是Re entrant Lock 重新进入锁。</p><p>对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><h2 id="公平锁非公平锁">1.5 公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p><p>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="分段锁">1.6 分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p><p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="偏向锁轻量级锁重量级锁">1.7 偏向锁/轻量级锁/重量级锁</h2><p>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p><h2 id="自旋锁">1.8 自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><h1 id="psaqs和cas">PS：AQS和CAS</h1><h2 id="aqs">1）AQS</h2><p>AbstractQueuedSynchronized 抽象队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…    </p><p>AQS维护了一个volatile int state(代表共享资源)和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。state的访问方式有三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively():该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAquire(<span class="keyword">int</span>):独占方式。尝试获取资源，成功则返回<span class="keyword">true</span>，失败则返回<span class="keyword">false</span>。</span><br><span class="line">tryRelease(<span class="keyword">int</span>):独占方式。尝试释放资源，成功则返回<span class="keyword">true</span>，失败则返回<span class="keyword">false</span>。</span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>):共享方式。尝试获取资源。负数表示失败；<span class="number">0</span>表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>):共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<span class="keyword">true</span>，否则返回<span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其他线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch为例，任务分为N个子线程去执行，state为初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后（即state=0），会unpark()主调用线程，然后主调用线程就会await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="cas">2) CAS</h2><p>CAS（Compare and Swap 比较并交换）是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS操作中包含三个操作数——需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值）。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p><p>JAVA对CAS的支持：</p><p>在JDK1.5中新增java.util.concurrent包就是建立在CAS之上的。相对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以java.util.concurrent包中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解getAndIncrement方法，该方法的作用相当于++i操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;  </span><br><span class="line">  　　<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;  </span><br><span class="line">  　　<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  　　　　<span class="keyword">return</span> value;  </span><br><span class="line">  　　&#125;  </span><br><span class="line"></span><br><span class="line"> 　　 <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  　　　　<span class="keyword">for</span> (;;)&#123;  </span><br><span class="line">  　　　　　　<span class="keyword">int</span> current = get();  </span><br><span class="line"> 　　　　　　<span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line"> 　　　　　　<span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"> 　　　　　　<span class="keyword">return</span> current;  </span><br><span class="line"> 　　　　&#125;  </span><br><span class="line"> 　　&#125;  </span><br><span class="line"></span><br><span class="line"> 　　<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>&#123;  </span><br><span class="line"> 　　　　<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line"> 　　&#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap put()函数的简要分析</title>
      <link href="/2022/01/22/%E5%9F%BA%E4%BA%8Ejava7HashMap%E6%BA%90%E7%A0%81%E7%9A%84%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/22/%E5%9F%BA%E4%BA%8Ejava7HashMap%E6%BA%90%E7%A0%81%E7%9A%84%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）.</p><p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><h1 id="hashmap的数据结构">1. HashMap的数据结构：</h1><p>HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</p><h1 id="put操作">2. put操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table .length );</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e. key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</p><p>PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</p><p>回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span> <span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</p><p>前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</p><p>得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span> <span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; ( <span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table. length);</span><br><span class="line">        hash = ( <span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 * table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment"> * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment"> * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment"> * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment"> *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment"> *        is irrelevant).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable. length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer. MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor , MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2 * oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。<br />生成新的数组后要执行transfer函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable. length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e. next;</span><br><span class="line">            <span class="keyword">if</span> ( rehash) &#123;</span><br><span class="line">                e. hash = <span class="keyword">null</span> == e. key ? <span class="number">0</span> : hash(e. key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e. next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</p><p>回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment"> * as part of Map construction or &quot;pseudo -construction&quot; (cloning,</span></span><br><span class="line"><span class="comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment"> * clone, and readObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates new entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry (<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</p><p>到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法的一些理解</title>
      <link href="/2022/01/19/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/19/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分治算法">1 什么是分治算法</h1><p>核心思想就是分而治之，将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并结果，就得到原问题的解。</p><p>这个定义看起来有点类似递归。</p><p>关于递归和分治的区别：<font color=red>分治算法是一种处理问题的思想，递归是一种编程技巧。</font></p><p>实际上，分治算法一般都比较适合用递归来实现，分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li><p>分解：将原问题分解成一系列子问题</p></li><li><p>解决：递归地求解各个子问题，若问题足够小，则直接求解</p></li><li><p>合并：将子问题的结果合并成原问题</p></li></ul><p>分治算法能解决的问题，一般需要满足下面的这几个条件：</p><ul><li><p>原问题与分解的小问题具有相同的模式</p></li><li><p>原问题分解成的子问题可以<strong>独立求解</strong>，这也是分治算法和动态规划的明显区别</p></li><li><p>具有分解终止条件，也就说，当问题足够小时，可以直接求解</p></li><li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</p></li></ul><h1 id="分治算法的应用">2 分治算法的应用</h1><p>分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。大部分数据结构和算法都是基于内存存储和单机处理。但是，如果要处理的数据量非常大，没法一次性放到内存中，这个时候，这些数据结构和算法就无法工作了。比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p>要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>假设给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠得很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><h1 id="分治算法在mapreduce中的体现">3 分治算法在MapReduce中的体现</h1><p>MapReduce 的本质就是分治思想，刚才举的订单的例子，数据有 10GB 大小，可能给你的感受还不够强烈，那如果要处理的数据是 1T，10T，100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于 Google 搜索引擎来说，网页爬取、清晰、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并，这不就是分治思想吗？</p><p>实际上，MapReduce 框架只是一个任务调度器，底层以来 GFS 来存储数据，以来 Borg 管理机器，它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一般机器出现宕机、进度卡壳等，就重新从 Borg 中调度一台机器来执行。</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛，它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理效率低下，就可以利用 MapReduce 提供高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、几百亿的网页 。</p><h1 id="分治算法的应用一些应用实例">4 分治算法的应用一些应用实例</h1><ul><li><p>快速排序算法</p></li><li><p>合并排序算法</p></li><li><p>桶排序算法</p></li><li><p>基数排序算法</p></li><li><p>二分查找算法</p></li><li><p>利用递归树求解算法复杂度的思想</p></li><li><p>分布式数据库利用分片技术做数据处理</p></li><li><p>MapReduce模型处理思想</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法的认知</title>
      <link href="/2022/01/14/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%A4%E7%9F%A5/"/>
      <url>/2022/01/14/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%A4%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统">1 推荐系统</h1><p>推荐系统即让系统根据已有的数据，比如用户的兴趣特点和动作行为，来判断用户对什么作品感兴趣，向用户推荐感兴趣的作品。</p><p><br /></p><h1 id="问题形式化">2 问题形式化</h1><p>按照机器学习基本的思路，我们应该对问题建模，然后对比模型和真实情况的差异，通过让差异最小化来帮助我们找到最佳的参数。对于推荐系统也是一样的。</p><p><br /></p><p>我们以抖音为例，假如我们有5个视频和4个用户</p><p><br /></p><table><tr><th>Video</th><th>u1</th><th>u2</th><th>u3</th><th>u4</th></tr><tr><td align="center">v1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">v2</td><td align="center">1</td><td align="center">-1</td><td align="center">-1</td><td align="center">0</td></tr><tr><td align="center">v3</td><td align="center">-1</td><td align="center">1</td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">v4</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">v5</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-1</td></tr></table><p>前三个是美食，后两个是美景</p><p><br /></p><p>通过表格我们很容易可以看出u1和u2比较喜欢美食，而u3和u4似乎比较喜欢美景，同时没有一个用户同时给所有视频点赞或评论。</p><p><br /></p><p>根据我们刚刚的陈述，我们希望根据已有的数据构建一个算法，然后通过算法预测出他们对未点赞或评论的视频的评价动向，以此为他们推荐视频。</p><h1 id="基于内容的推荐系统">3 基于内容的推荐系统</h1><p>我们刚刚根据不同视频的类别来判断了不同用户对不同类型视频的喜好，基于此，我们可以想到为每一个视频都建立一个特征向量，用这个特征向量来表示视频的特征，那我们如何表示用户对某个视频的喜好程度呢？</p><p><br /></p><p>结合刚刚的栗子，我们应该给用户建立一个参数向量，来表示他们对不同类别视频的偏爱程度。</p><h1 id="单用户的代价函数">4 单用户的代价函数</h1><p>设用户<span class="math inline">\(j\)</span>的参数向量为<span class="math inline">\(\theta ^ j\)</span>，第<span class="math inline">\(i\)</span>个视频的特征值为<span class="math inline">\(x^i\)</span>，就像我们在线性回归中所作的那样，我们很自然的考虑如下的代价函数</p><p><span class="math inline">\(\min\limits_{\theta^j} \frac{1}{2} \sum\limits_{i:r(i,j)=1} ((\theta^{j})^Tx^{i}-y^{(i,j)})^2\)</span></p><p>其中<span class="math inline">\(i:r(i,j)=1\)</span>表示我们只计算用户<span class="math inline">\(j\)</span>所看过的那些视频，注意的是在一般的线性回归中我们会乘上<span class="math inline">\(\frac{1}{2m}\)</span>，但是这里我们没有这么做，一是因为扩大缩小常数倍是不影响极值点的，二是我们只计算了部分视频，加上参数会带来一些因为数值较小而遇到的麻烦。</p><h1 id="所有用户的代价函数">5 所有用户的代价函数</h1><p>只需对所有的用户求和即可</p><p><span class="math inline">\(\min\limits_{\theta^1,...,\theta^{n_u}} \frac{1}{2} \sum_{j=1}^{n_u}\sum\limits_{i:r(i,j)=1} ((\theta^{j})^Tx^{i}-y^{(i,j)})^2\)</span></p><p>用梯度下降法来更新参数只需要求一次导即可，比较简单，就不多写了</p><h1 id="协同过滤">6 协同过滤</h1><p>在之前基于内容的推荐系统中，我们根据视频的特征训练出了用户参数，同样的，我们可以根据用户参数训练出视频的特征</p><p><span class="math inline">\(\min\limits_{x^1,...,x^{n_m}} \frac{1}{2} \sum\limits_{i=1}^{n_m}\sum\limits_{j:r(i,j)=1} ((\theta^{j})^Tx^{i}-y^{(i,j)})^2\)</span></p><p>但是如果我们既没有用户的参数，也没有视频的特征该怎么办呢？其实这也是工业界研究的比较多的关于推荐系统的问题，也叫冷启动问题。</p><p><br /></p><p>名字非常的形象，刚刚启动的系统处于一个“冷”状态，意味着数据量小，在不断的积累数据的过程中，算法的表现也越来越好，系统逐渐“手感火热”</p><p><br /></p><p>而对于协同过滤算法，它的基本思想是这样的</p><p><br /></p><ul><li><p>我们会初始化<span class="math inline">\(x^1,x^2,…,x^{n_m},\theta^1,…,\theta^{n_u}\)</span>为一些比较小的值，这样在冷启动时为用户的推荐就会比较随机</p></li><li><p>修改优化目标，结合求用户参数和视频特征的代价函数，让新的代价函数同时对<span class="math inline">\(x\)</span>和<span class="math inline">\(θ\)</span>进行，并使用梯度下降法进行训练</p></li><li><p>训练完算法后，我们会对用户<span class="math inline">\(j\)</span>对视频<span class="math inline">\(i\)</span>的点赞或评论做出预测</p></li></ul><h1 id="总结">7 总结</h1><p>基于内容的推荐只考虑了对象本身的性质，提取出对象的特征，然后来和用户参数进行计算。</p><p><br /></p><p>而基于协同过滤的推荐算法考虑到了全部的数据，推荐的个性化程度比较高一些</p><p><br /></p><p>你可以想象，让<span class="math inline">\(\theta^1,…,\theta^{n_u}\)</span>固定时，我们其实是在考虑用户的历史习惯，固定<span class="math inline">\(x^1,…,x^{n_m}\)</span></p><p>时，我们其实是在考虑兴趣相近的用户可能会对同样的东西感兴趣。这也是协同过滤的假设。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop伪分布式环境</title>
      <link href="/2022/01/12/hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/01/12/hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="hadoop生态圈">1 Hadoop生态圈</h1><h2 id="什么是hadoop">1.1 什么是hadoop</h2><p>Hadoop 是一个能够对大量数据进行分布式处理的软件框架，具有可靠、高效、可伸缩的特点。Hadoop 的核心是 <strong>HDFS</strong>和 <strong>Mapreduce</strong>。Hadoop能将单机的工作任务进行分拆，变成协同工作的集群，解决了日益增加的文件存储量和数据量的瓶颈问题，hadoop是使用面向对象java语言编写的，因此它的拓展性也是非常的好。</p><h2 id="hdfs分布式文件系统">1.2 HDFS分布式文件系统</h2><p>HDFS是Hadoop生态圈中的一个组件，是一个独立的分布式文件系统，是开源免费的大数据 处理文件存储系统。HDFS是<strong>Master</strong>和<strong>Slave</strong>的主从结构。主要由<strong>Name-Node</strong>、<strong>Secondary NameNode</strong>、<strong>DataNode</strong>构成。当客户需要写数据时，先在NameNode 上创建文件结构并确定数据块副本将要写道哪几个 datanode ，然后将多个代写 DataNode 组成一个写数据管道，保证写入过程完整统一写入。读取数据时则先通过 NameNode 找到存储数据块副本的所有 DataNode ，根据与读取客户端距离排序数据块，然后取最近的。</p><h3 id="name-node">1.2.1 Name-Node</h3><p>Name-Node是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等</p><h3 id="secondary-namenode">1.2.2 Secondary NameNode</h3><p>Secondary NameNode主要是辅助 NameNode，分担其工作，紧急情况可以辅助恢复</p><h3 id="datanode">1.2.3 DataNode</h3><p>DataNode是Slave节点，实际存储数据、执行数据块的读写并汇报存储信息给NameNode</p><h2 id="mapreduce编程模型">1.3 MapReduce编程模型</h2><p> MapReduce是一种编程模型，是一种编程方法，是抽象的理论，采用了<font color=red>分而治之</font>的思想。MapReduce框架的核心步骤主要分两部分，分别是<strong>Map</strong>和<strong>Reduce</strong>。每个文件分片由单独的机器去处理，这就是Map的方法，将各个机器计算的结果汇总并得到最终的结果，这就是Reduce的方法。Map 函数就近读入 HDFS 分片数据，并将Map 处理结果先写入环形内存缓冲区。如果当缓冲区写到一定阈值则开始分割如文件，此期间会按 Reduce 个数进行数据分区并且按相同键值进行分区内排序，然后写入输出分区文件。reduce 函数开始时会从各自已经完成的Map 输出结果的节点中选择自己需要的数据分区复制到自己的节点，并进行合并及排序，再将此数据作为输入进行 Reduce 处理，最后将结果输出到 HDFS 中。充分利用各个结点的计算资源分布、并行的完成 Mapreduce处理。</p><h1 id="hadoop伪分布式环境搭建">2 hadoop伪分布式环境搭建</h1><p>Hadoop伪分布式搭建首先要下载VMware新建虚拟机配置好网络连接，为了方便操作管理虚拟机，使用FinalShell可视化界面进行操作，其次要准备好jdk和hadoop安装包，接下来就可以进行hadoop伪分布式的搭建了，以下操作都是使用FinalShell通过ip地址连接到虚拟机之后，在FinalShell中进行的操作。</p><h2 id="关闭防火墙">1）关闭防火墙</h2><p>service iptables start; # 立即开启防火墙，但是重启后失效。</p><p>service iptables stop; # 立即关闭防火墙，但是重启后失效。</p><p>chkconfig iptables on; # 开启防火墙，重启后生效</p><p>chkconfig iptables off; # 关闭防火墙，重启后生效</p><h2 id="配置主机名">2）配置主机名</h2><p>配置/etc/sysconfig目录下的<strong>network</strong>文件，进入后使用vim命令进行编辑，设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=hadoop01</span><br></pre></td></tr></table></figure><p>使用wq！命令进行保存，因为是系统文件，在编辑完之后不要忘了source一下。</p><h2 id="配置hosts">3）配置Hosts</h2><p>在/etc/hosts文件中填入 ip地址和对应的主机名</p><h2 id="配置免密互通">4）配置免密互通</h2><p>在命令行输入ssh-keygen命令，出现提示后填写y，因为网络协议问题，如果不配置的话远程主机访问可能每次都要输入密码，相当繁琐。</p><h2 id="安装jdk和hadoop">5）安装jdk和hadoop</h2><p>将准备好的文件在FinalShell软件中直接拖拽进入虚拟机中，在命令行使用tar -zvxf+地址 分别解压jdk和hadoop。</p><h2 id="配置hadoop">6）配置hadoop</h2><p><strong>① 修改 hadoop-env.sh</strong></p><p>主要是修改java_home的路径，在hadoop-env.sh的第27行,把</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$&#123;JAVA_HOME&#125;</span><br></pre></td></tr></table></figure><p>修改成具体的路径，最后source一下</p><p><strong>② 修改 core-site.xml</strong></p><p>主要用来增加namenode配置、文件存储位置配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--用来指定hdfs的老大，namenode的地址--&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--用来指定hadoop运行时产生文件的存放目录--&gt;</span>    </span><br><span class="line">                  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/park/work/hadoop-2.7.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③修改 hdfs-site.xml</strong></p><p>主要是配置包括自身在内的备份副本数量。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--指定hdfs保存数据副本的数量，包括自己，默认为3--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--伪分布式模式，此值必须为1--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p></property></p><p></configuration></p><p><strong>④修改 mapred-site.xml</strong></p><p>主要是配置mapreduce运行在yarn上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--指定hdfs保存数据副本的数量，包括自己，默认为3--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--伪分布式模式，此值必须为1--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p></property></p><p></configuration></p><p><strong>⑤修改 yarn-site.xml</strong></p><p>主要是配置yarn的resourcemanager地址</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--NodeManager获取数据的方式--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p></property></p><p></configuration></p><p><strong>⑥修改 slaves</strong></p><p>因为hadoop本身就是个主从结构的多节点，但在伪分布式中只有这样一个结点。</p><p><strong>⑦配置hadoop的环境变量</strong></p><p>在etc文件夹下使用vim命令编辑profile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> HADOOP_HOME=具体路径</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> PATH=具体路径/bin</span><br></pre></td></tr></table></figure><p>系统文件保存后需要重新source一下。</p><p><strong>⑧格式化namenode</strong></p><p>在hadoop/bin目录下使用命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namenode hadoop namenode -format</span><br></pre></td></tr></table></figure><p>格式化成功的标志是:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Storage directory /tmp/hadoop-root/dfs/name has     been successfully formatted</span><br></pre></td></tr></table></figure><p>以上配置全部结束以后启动伪分布式集群：</p><p><strong>start-all.sh</strong></p><p>使用<strong>jps</strong>命令查看进程</p><p>如果看到五个进程</p><p>那么hadoop伪分布式集群就启动成功了</p><p>也可以在浏览器中输入 虚拟机ip地址的50070端口查看可视化界面</p><p>如果集群正常启动，而无法访问可视化界面，则非常有可能就是防火墙未关闭</p><p>最后关闭集群，命令是</p><p><strong>stop-all.sh</strong></p><p><br /></p><p><strong>附:</strong></p><p><strong>常用的hdfs命令</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /user/trunk  创建目录 </span><br><span class="line">hadoop fs -ls /user 列举 </span><br><span class="line">hadoop fs -lsr /user   (递归的) </span><br><span class="line">hadoop fs -put test.txt /user/trunk 上传文件 </span><br><span class="line">hadoop fs -put test.txt .(复制到hdfs当前目录下） </span><br><span class="line">hadoop fs -get /user/trunk/test.txt . (复制到本地当前目录下) 下载 </span><br><span class="line">hadoop fs -cat /user/trunk/test.txt 查看文件内容 </span><br><span class="line">hadoop fs -tail /user/trunk/test.txt  (查看最后<span class="number">1000</span>字节) </span><br><span class="line">hadoop fs -rm /user/trunk/test.txt </span><br><span class="line">hadoop fs -rmdir /user/trunk </span><br><span class="line">hadoop fs -<span class="built_in">help</span> ls (查看ls命令的帮助文档)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/2022/01/10/hello-world/"/>
      <url>/2022/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p><br /></p><p>你好，我是<strong>res</strong>，一个爱生活的人</p><p><br /></p><p>目前是<strong>CUCN</strong>四年级的一名学生亦是base上海的一名<strong>ByteDancer</strong></p><p>我的主要研究方向是：<strong>各类算法、Android/ios后端开发、大数据技术、计算机视觉</strong></p><p>我对<strong>人工智能</strong>也有很大的兴趣，但很多知识没有很深的了解，目前还在学习中</p><p><br /></p><p>未来，我将会在此博客上记录成长点滴，分享技术随笔</p><p>我的家在<strong>苏州</strong>，学校在<strong>南京</strong>，公司在<strong>上海</strong>，因此我常穿梭在以上三城之中</p><p>可以在博客首页联系我，也欢迎各位面基，技术交流畅谈人生我奉陪到底</p><p><br /></p><h5 id="共勉">共勉</h5><p>很喜欢 <strong>《踮脚张望的时光》</strong> 中的一段话，我时常用来勉励自己，送给屏幕前的你</p><blockquote><p><font color=#00BFFF>总有一天你将破蛹而出，成长得比人们期待的还要美丽。</font></p><p><font color=#00BFFF>但这个过程会很痛，会很辛苦，有时候还会觉得灰心。</font></p><p><font color=#00BFFF>面对着汹涌而来的现实，觉得自己渺小无力。</font></p><p><font color=#00BFFF>但这，也是生命的一部分。</font></p><p><font color=#00BFFF>做好现在你能做的，然后，一切都会好的。</font></p><p><font color=#00BFFF>我们都将孤独地长大，不要害怕。</font></p><p><font color=#00BFFF>- - 寂地</font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
